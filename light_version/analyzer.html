<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Access Log Analyzer (Light)</title>
    <!-- Chart.js, Adapter, and Zoom Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
        }

        .drop-zone {
            border: 2px dashed #cbd5e1;
            transition: all 0.3s ease;
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }

        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }

        .card {
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            padding: 1.5rem;
        }

        .loading-overlay {
            background: rgba(255, 255, 255, 0.9);
        }
    </style>
</head>

<body class="text-slate-800">

    <!-- Header -->
    <nav class="bg-white shadow-sm border-b border-slate-200">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <span class="text-2xl font-bold text-blue-600 tracking-tight">Access Log Analyzer</span>
                    <span class="ml-2 text-xs font-semibold bg-blue-100 text-blue-800 px-2 py-0.5 rounded">Light</span>
                </div>
                <div class="flex items-center space-x-4">
                    <button onclick="resetZoom()" class="text-blue-600 hover:text-blue-800 text-sm font-medium">Reset
                        Zoom</button>
                    <a href="#" onclick="window.location.reload()"
                        class="text-slate-500 hover:text-slate-700 text-sm">Reset All</a>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">

        <!-- File Upload Section -->
        <div id="uploadSection" class="transition-all duration-300">
            <div class="card drop-zone flex flex-col items-center justify-center p-12 text-center cursor-pointer"
                onclick="document.getElementById('fileInput').click()">
                <div class="rounded-full bg-blue-50 p-4 mb-4">
                    <svg class="w-8 h-8 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                        </path>
                    </svg>
                </div>
                <h3 class="text-lg font-semibold text-slate-900">Drop log file here</h3>
                <p class="mt-2 text-sm text-slate-500">Supports .log, .txt, .gz (ALB, Apache, JSON)</p>
                <input type="file" id="fileInput" class="hidden" accept=".log,.txt,.gz,.json">
            </div>
        </div>

        <!-- Progress Indicator (Hidden by default) -->
        <div id="progressSection" class="hidden mt-6">
            <div class="card">
                <div class="flex justify-between mb-1">
                    <span class="text-sm font-medium text-blue-700">Processing...</span>
                    <span class="text-sm font-medium text-blue-700" id="progressText">0%</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div class="bg-blue-600 h-2.5 rounded-full" id="progressBar" style="width: 0%"></div>
                </div>
                <p id="statusText" class="text-xs text-slate-500 mt-2">Initializing...</p>
            </div>
        </div>

        <!-- Dashboard (Hidden by default) -->
        <div id="dashboardSection" class="hidden space-y-6 mt-6">

            <!-- Summary Stats -->
            <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
                <div class="card border-l-4 border-blue-500">
                    <p class="text-sm font-medium text-slate-500">Total Requests</p>
                    <p class="text-2xl font-bold text-slate-800" id="totalRequests">-</p>
                </div>
                <div class="card border-l-4 border-green-500">
                    <p class="text-sm font-medium text-slate-500">Data Transferred</p>
                    <p class="text-2xl font-bold text-slate-800" id="totalBytes">-</p>
                </div>
                <div class="card border-l-4 border-yellow-500">
                    <p class="text-sm font-medium text-slate-500">Error Rate (4xx/5xx)</p>
                    <p class="text-2xl font-bold text-slate-800" id="errorRate">-</p>
                </div>
                <div class="card border-l-4 border-purple-500">
                    <p class="text-sm font-medium text-slate-500">Unique IPs</p>
                    <p class="text-2xl font-bold text-slate-800" id="uniqueIPs">-</p>
                </div>
            </div>

            <!-- Charts Row 1 -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Time Series -->
                <div class="card loading-target">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold">Requests over Time</h3>
                        <select id="timeInterval" onchange="renderTimeChart()"
                            class="text-sm border-slate-300 rounded-md shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                            <option value="1000">1 Second</option>
                            <option value="10000">10 Seconds</option>
                            <option value="60000" selected>1 Minute</option>
                        </select>
                    </div>
                    <div class="chart-container">
                        <canvas id="timeChart"></canvas>
                    </div>
                </div>
                <!-- Status Dist -->
                <div class="card loading-target">
                    <h3 class="text-lg font-semibold mb-4">Status Codes</h3>
                    <div class="chart-container">
                        <canvas id="statusChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Charts Row 2 -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- XLog (Scatter) -->
                <div class="card loading-target col-span-1 lg:col-span-2 relative">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold">XLog (Response Time Analysis)</h3>
                        <div class="text-sm bg-slate-100 px-3 py-1 rounded text-slate-600">
                            Visible Points: <span id="xlogVisibleCount" class="font-bold text-slate-900">-</span>
                        </div>
                    </div>
                    <p class="text-xs text-slate-500 mb-2">Drag to zoom (X/Y), Shift+Drag to pan. Hover for details.
                    </p>
                    <div class="chart-container">
                        <canvas id="xlogChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Charts Row 3 -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Top URIs -->
                <div class="card loading-target">
                    <h3 class="text-lg font-semibold mb-4">Top 10 Requested URIs</h3>
                    <div class="chart-container">
                        <canvas id="uriChart"></canvas>
                    </div>
                </div>
                <!-- Top IPs -->
                <div class="card loading-target overflow-hidden">
                    <h3 class="text-lg font-semibold mb-4">Top 10 Client IPs</h3>
                    <div class="overflow-x-auto h-[300px]">
                        <table class="min-w-full text-sm text-left">
                            <thead class="bg-slate-50 text-slate-600 font-medium">
                                <tr>
                                    <th class="px-4 py-2">IP Address</th>
                                    <th class="px-4 py-2 text-right">Count</th>
                                    <th class="px-4 py-2 text-right">%</th>
                                </tr>
                            </thead>
                            <tbody id="ipTableBody" class="divide-y divide-slate-100">
                                <!-- JS Populated -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

        </div>
    </main>

    <script>
        // State
        const state = {
            totalRequests: 0,
            totalBytes: 0,
            statusCounts: {},
            uriCounts: {},
            ipCounts: {},
            timeSeriesSec: {}, // Bucket by second (epoch / 1000)
            xlogData: [],   // Array of {x: time, y: duration, s: status, u: uri}
            charts: {}
        };

        // Constants
        const MAX_XLOG_POINTS = 1000000;
        const UPDATE_INTERVAL_MS = 1000;

        // Regex Patterns
        // 1. ALB: specific space separated
        const PATTERN_ALB = /^([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*):([0-9]*) ([^ ]*)[:-]([0-9]*) ([-.0-9]*) ([-.0-9]*) ([-.0-9]*) (|[-0-9]*) (-|[-0-9]*) ([-0-9]*) ([-0-9]*) "([^ ]*) (.*?) (- |[^ ]*)" "([^"]*)" (.*)/;

        // 2. Common/Combined extended: 
        // Standard: IP - - [Date] "Req" Status Bytes
        // Extended found in user log: IP - - [Date] "Req" Status Bytes OptionalResponseTime
        // Regex: 
        // Group 1: IP
        // Group 4: Date
        // Group 5: Request
        // Group 6: Status
        // Group 7: Bytes
        // Group 8: (Optional) Response Time (common in Tomcat/Windchill as integer micros or millis) OR Referer
        // To be safe, we'll try to match standard CLF first parts, then grab the rest for heuristic parsing
        const PATTERN_CLF_BASE = /^([^ ]*) ([^ ]*) ([^ ]*) \[([^\]]*)\] "([^"]*)" ([0-9]*) ([0-9\-]*) (.*)/;

        // DOM Elements
        const dropZone = document.querySelector('.drop-zone');
        const fileInput = document.getElementById('fileInput');

        function resetZoom() {
            if (state.charts.time) state.charts.time.resetZoom();
            if (state.charts.xlog) state.charts.xlog.resetZoom();
        }

        // Drag & Drop Handlers
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', (e) => { if (e.target.files.length) handleFile(e.target.files[0]); });

        // Main File Handler
        async function handleFile(file) {
            // UI Update
            document.getElementById('uploadSection').classList.add('hidden');
            document.getElementById('progressSection').classList.remove('hidden');
            document.getElementById('statusText').innerText = `Opening ${file.name}...`;

            try {
                let stream = file.stream();
                if (file.name.endsWith('.gz')) {
                    const decompressor = new DecompressionStream('gzip');
                    stream = stream.pipeThrough(decompressor);
                }

                const reader = stream.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let processedBytes = 0;
                let lastUiUpdate = Date.now();
                let logType = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    processedBytes += value.byteLength;
                    buffer += decoder.decode(value, { stream: true });

                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    if (!logType && lines.length > 0) {
                        logType = detectLogType(lines[0]);
                        console.log("Detected Log Type:", logType);
                        document.getElementById('statusText').innerText = `Parsing as ${logType}...`;
                    }

                    lines.forEach(line => {
                        if (!line.trim()) return;
                        parseLine(line, logType);
                    });

                    if (Date.now() - lastUiUpdate > UPDATE_INTERVAL_MS) {
                        const mb = (processedBytes / 1024 / 1024).toFixed(1);
                        document.getElementById('progressText').innerText = `${mb} MB`;
                        // Improve progress bar accuracy mainly for non-gz files. 
                        const percent = file.name.endsWith('.gz') ? 100 : Math.min(100, (processedBytes / file.size) * 100);
                        document.getElementById('progressBar').style.width = `${percent}%`;
                        lastUiUpdate = Date.now();
                    }
                }

                if (buffer.trim()) parseLine(buffer, logType);

                document.getElementById('statusText').innerText = "Processing Complete. Rendering Dashboard...";
                document.getElementById('progressBar').style.width = '100%';

                setTimeout(renderDashboard, 100);

            } catch (err) {
                console.error(err);
                alert("Error reading file: " + err.message);
                window.location.reload();
            }
        }

        function detectLogType(line) {
            if (line.trim().startsWith('{')) return 'JSON';
            if (line.match(PATTERN_ALB)) return 'ALB';
            if (line.match(PATTERN_CLF_BASE)) return 'CLF';
            return 'UNKNOWN';
        }

        function parseLine(line, type) {
            if (type === 'UNKNOWN') return;

            let entry = {};

            if (type === 'ALB') {
                const match = line.match(PATTERN_ALB);
                if (!match) return; // Skip invalid
                entry.time = match[2];
                // ALB Response Time = Request + Target + Response Processing
                // Often we care about Target processing time (9) which is the backend time
                // Or total time. Let's sum them.
                const t1 = parseFloat(match[8] || 0);
                const t2 = parseFloat(match[9] || 0);
                const t3 = parseFloat(match[10] || 0);
                entry.responseTime = (t1 + t2 + t3); // Seconds

                entry.timestamp = new Date(entry.time).getTime();

                const reqParts = (match[16] || "").split(' ');
                entry.method = reqParts[0];
                entry.url = reqParts[1];
                entry.status = match[11]; // ELB Status Code
                entry.bytes = parseInt(match[14] || 0); // Sent Bytes
                entry.clientIp = match[4];
            }
            else if (type === 'CLF') {
                const match = line.match(PATTERN_CLF_BASE);
                if (!match) return;

                // 1=ip, 4=time, 5=req, 6=status, 7=bytes, 8=tail
                entry.clientIp = match[1];

                // Time Parse: 16/Jan/2026:00:04:37 +0900
                const timeStr = match[4].replace(':', ' ');
                entry.timestamp = Date.parse(timeStr);

                const reqParts = (match[5] || "").split(' ');
                entry.method = reqParts[0];
                entry.url = reqParts[1];
                entry.status = match[6];
                entry.bytes = (match[7] === '-' ? 0 : parseInt(match[7]));

                // Heuristic for Response Time in tail (Group 8)
                // Common formats:
                // "Referer" "UA"
                // "Referer" "UA" ResponseTime
                // ResponseTime
                const tail = match[8].trim();

                // Check if the tail ends with a number
                const tailParts = tail.split(' ');
                const lastPart = tailParts.length > 0 ? tailParts[tailParts.length - 1] : "";

                // If last part is numeric, assume it's response time
                // Windchill uses microseconds often (e.g. 562386)
                if (/^\d+$/.test(lastPart)) {
                    const val = parseInt(lastPart);
                    // Heuristic: if value > 1000000, probably micros. If > 1000, probably millis? 
                    // Or just assume Micros if it looks like typical Windchill logs
                    // 562386 micros = 0.5s. 562386 millis = 562s (too long). 
                    // Let's assume MICROSECONDS (us) and convert to SECONDS.

                    // However, "0" is ambiguous. 
                    // "562386" -> 0.56s.
                    // "15622" -> 0.015s.
                    entry.responseTime = val / 1000000.0;
                } else {
                    entry.responseTime = 0;
                }
            }
            else if (type === 'JSON') {
                try {
                    const json = JSON.parse(line);
                    entry.time = json.time || json.timestamp || json.datetime;
                    entry.timestamp = new Date(entry.time).getTime();
                    entry.url = json.url || json.request_uri || json.path;
                    entry.method = json.method || 'GET';
                    entry.status = json.status || 200;
                    entry.bytes = json.bytes_sent || 0;
                    entry.clientIp = json.client_ip || 'unknown';
                    entry.responseTime = parseFloat(json.request_time || json.duration || 0);
                } catch (e) { return; }
            }

            if (!entry.timestamp || isNaN(entry.timestamp)) return;

            state.totalRequests++;
            state.totalBytes += (entry.bytes || 0);

            state.statusCounts[entry.status] = (state.statusCounts[entry.status] || 0) + 1;

            const uriClean = (entry.url || "").split('?')[0];
            state.uriCounts[uriClean] = (state.uriCounts[uriClean] || 0) + 1;
            state.ipCounts[entry.clientIp] = (state.ipCounts[entry.clientIp] || 0) + 1;

            // Time Series - Bucket by SECOND now
            const bucketSec = Math.floor(entry.timestamp / 1000);
            state.timeSeriesSec[bucketSec] = (state.timeSeriesSec[bucketSec] || 0) + 1;

            if (entry.responseTime > 0) {
                if (state.xlogData.length < MAX_XLOG_POINTS) {
                    state.xlogData.push({ x: entry.timestamp, y: entry.responseTime, s: entry.status, u: uriClean });
                } else if (Math.random() < 0.1) {
                    const idx = Math.floor(Math.random() * MAX_XLOG_POINTS);
                    state.xlogData[idx] = { x: entry.timestamp, y: entry.responseTime, s: entry.status, u: uriClean };
                }
            }
        }

        function renderDashboard() {
            document.getElementById('progressSection').classList.add('hidden');
            document.getElementById('dashboardSection').classList.remove('hidden');

            document.getElementById('totalRequests').innerText = state.totalRequests.toLocaleString();
            const gb = state.totalBytes / (1024 * 1024 * 1024);
            document.getElementById('totalBytes').innerText = gb > 1 ? `${gb.toFixed(2)} GB` : `${(state.totalBytes / 1024 / 1024).toFixed(0)} MB`;

            let errors = 0;
            Object.keys(state.statusCounts).forEach(c => {
                if (c.startsWith('4') || c.startsWith('5')) errors += state.statusCounts[c];
            });
            const rate = state.totalRequests ? (errors / state.totalRequests * 100).toFixed(2) : 0;
            document.getElementById('errorRate').innerText = `${rate}%`;
            document.getElementById('uniqueIPs').innerText = Object.keys(state.ipCounts).length.toLocaleString();

            renderTimeChart();
            renderStatusChart();
            renderTopUris();
            renderIpTable();
            renderXLog();
        }

        function renderTimeChart() {
            const ctx = document.getElementById('timeChart').getContext('2d');
            const intervalMs = parseInt(document.getElementById('timeInterval').value);

            // Aggregate buckets
            const aggregated = {};
            Object.entries(state.timeSeriesSec).forEach(([sec, count]) => {
                // sec is epoch seconds. 
                const ms = parseInt(sec) * 1000;
                const bucket = Math.floor(ms / intervalMs) * intervalMs;
                aggregated[bucket] = (aggregated[bucket] || 0) + count;
            });

            const labels = Object.keys(aggregated).sort();
            const data = labels.map(t => ({ x: parseInt(t), y: aggregated[t] }));

            if (state.charts.time) state.charts.time.destroy();

            state.charts.time = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Requests',
                        data: data,
                        borderColor: '#2563eb',
                        backgroundColor: 'rgba(37, 99, 235, 0.1)',
                        fill: true,
                        tension: 0.1,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { type: 'time', time: { unit: 'minute' } },
                        y: { beginAtZero: true }
                    },
                    plugins: {
                        legend: { display: false },
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                drag: { enabled: true },
                                mode: 'x',
                            },
                            pan: { enabled: true, mode: 'x', }
                        }
                    }
                }
            });
        }

        function renderStatusChart() {
            const ctx = document.getElementById('statusChart').getContext('2d');
            const sorted = Object.entries(state.statusCounts).sort((a, b) => b[1] - a[1]);
            const top5 = sorted.slice(0, 5);
            const others = sorted.slice(5).reduce((acc, curr) => acc + curr[1], 0);

            const labels = top5.map(x => x[0]);
            const data = top5.map(x => x[1]);
            if (others > 0) { labels.push('Other'); data.push(others); }

            const bgColors = labels.map(l => {
                if (l.startsWith('2')) return '#22c55e';
                if (l.startsWith('3')) return '#3b82f6';
                if (l.startsWith('4')) return '#eab308';
                if (l.startsWith('5')) return '#ef4444';
                return '#94a3b8';
            });

            new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: bgColors,
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { position: 'right' } }
                }
            });
        }

        function renderTopUris() {
            const ctx = document.getElementById('uriChart').getContext('2d');
            const sorted = Object.entries(state.uriCounts).sort((a, b) => b[1] - a[1]).slice(0, 10);

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sorted.map(x => x[0]),
                    datasets: [{
                        label: 'Requests',
                        data: sorted.map(x => x[1]),
                        backgroundColor: '#60a5fa',
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: { legend: { display: false } }
                }
            });
        }

        function renderIpTable() {
            const tbody = document.getElementById('ipTableBody');
            tbody.innerHTML = '';
            const sorted = Object.entries(state.ipCounts).sort((a, b) => b[1] - a[1]).slice(0, 50);

            sorted.forEach(([ip, count]) => {
                const tr = document.createElement('tr');
                const pct = (count / state.totalRequests * 100).toFixed(1);
                tr.innerHTML = `<td class="px-4 py-2 font-mono text-xs text-slate-600">${ip}</td><td class="px-4 py-2 text-right font-medium">${count.toLocaleString()}</td><td class="px-4 py-2 text-right text-slate-400 text-xs">${pct}%</td>`;
                tbody.appendChild(tr);
            });
        }

        function renderXLog() {
            const ctx = document.getElementById('xlogChart').getContext('2d');

            const datasets = [];
            const byStatus = {};
            state.xlogData.forEach(p => {
                const s = p.s || '000';
                if (!byStatus[s]) byStatus[s] = [];
                byStatus[s].push(p);
            });

            const statusColors = { '2': '#22c55e', '3': '#3b82f6', '4': '#eab308', '5': '#ef4444' };

            Object.keys(byStatus).forEach(status => {
                const codePrefix = status.charAt(0);
                const color = statusColors[codePrefix] || '#94a3b8';
                datasets.push({
                    label: `Status ${status}`,
                    data: byStatus[status],
                    backgroundColor: color,
                    pointRadius: 3,
                    pointHoverRadius: 5
                });
            });

            if (state.charts.xlog) state.charts.xlog.destroy();

            const updateVisibleCount = (chart) => {
                const xScale = chart.scales.x;
                const yScale = chart.scales.y;
                let count = 0;
                chart.data.datasets.forEach(ds => {
                    ds.data.forEach(pt => {
                        if (pt.x >= xScale.min && pt.x <= xScale.max && pt.y >= yScale.min && pt.y <= yScale.max) {
                            count++;
                        }
                    });
                });
                document.getElementById('xlogVisibleCount').innerText = count.toLocaleString();
            };

            state.charts.xlog = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        onComplete: (ani) => updateVisibleCount(ani.chart)
                    },
                    scales: {
                        x: {
                            type: 'time',
                            title: { display: true, text: 'Time' },
                            time: { displayFormats: { minute: 'HH:mm' } }
                        },
                        y: {
                            title: { display: true, text: 'Duration (s)' },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: { display: true },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const pt = ctx.raw;
                                    return `[${pt.s}] ${pt.y.toFixed(3)}s - ${pt.u}`;
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                drag: { enabled: true },
                                mode: 'xy',
                                onZoomComplete: ({ chart }) => updateVisibleCount(chart)
                            },
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                modifierKey: 'shift',
                                onPanComplete: ({ chart }) => updateVisibleCount(chart)
                            }
                        }
                    }
                }
            });
            updateVisibleCount(state.charts.xlog);
        }
    </script>
</body>

</html>